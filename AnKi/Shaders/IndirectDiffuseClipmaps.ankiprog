// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki 16bit

#pragma anki mutator RAYS_PER_PROBE_PER_FRAME 32 64

#pragma anki technique RtMaterialFetch rgen mutators
#pragma anki technique PopulateCaches comp mutators RAYS_PER_PROBE_PER_FRAME
#pragma anki technique Test comp mutators
#pragma anki technique VisualizeProbes vert pixel mutators

#define ANKI_ASSERTIONS_ENABLED 1

#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/Functions.hlsl>
#include <AnKi/Shaders/SH.hlsl>
#include <AnKi/Shaders/Include/MiscRendererTypes.h>
#include <AnKi/Shaders/ImportanceSampling.hlsl>
#include <AnKi/Shaders/PackFunctions.hlsl>
#include <AnKi/Shaders/SH.hlsl>
#include <AnKi/Shaders/IrradianceDice.hlsl>
#include <AnKi/Shaders/FastMathFunctions.hlsl>

#define CLIPMAP_VOLUME 1
#include <AnKi/Shaders/RtMaterialFetch.hlsl>

constexpr Vec3 kIndirectDiffuseClipmapForwardOffset = Vec3(10.0, 5.0, 10.0); // In meters

void computeClipmapBounds(Clipmap clipmap, Vec3 cameraPos, Vec3 lookDir, out Vec3 aabbMin, out Vec3 aabbMax)
{
	const Vec3 offset = normalize(Vec3(lookDir.x, 0.0, lookDir.z)) * kIndirectDiffuseClipmapForwardOffset;
	cameraPos += offset;

	const Vec3 halfSize = clipmap.m_size * 0.5;
	const Vec3 probeSize = clipmap.m_size / clipmap.m_probeCounts;
	const Vec3 roundedPos = round(cameraPos / probeSize) * probeSize;
	aabbMin = roundedPos - halfSize;
	aabbMax = roundedPos + halfSize;
}

F32 computeClipmapFade(Clipmap clipmap, Vec3 cameraPos, Vec3 lookDir, Vec3 worldPos)
{
	const Vec3 offset = normalize(Vec3(lookDir.x, 0.0, lookDir.z)) * kIndirectDiffuseClipmapForwardOffset;

	cameraPos += offset;

	const Vec3 probeSize = clipmap.m_size / clipmap.m_probeCounts;
	const Vec3 halfSize = clipmap.m_size * 0.5;
	const Vec3 aabbMin = cameraPos - halfSize + probeSize;
	const Vec3 aabbMax = cameraPos + halfSize - probeSize;

	Vec3 a = (worldPos - aabbMin) / (aabbMax - aabbMin);
	a = 2.0 * a - 1.0;
	a = pow(abs(a), 8.0);
	a = 1.0 - a;

	a = select(a > 1.0, 0.0, a);
	a = max(0.0, a);

	F32 fade = a.x * a.y * a.z;

	return fade;
}

F32 computeClipmapFade2(Clipmap clipmap, Vec3 cameraPos, Vec3 lookDir, Vec3 worldPos)
{
	Vec3 aabbMin, aabbMax;
	computeClipmapBounds(clipmap, cameraPos, lookDir, aabbMin, aabbMax);

	if(all(worldPos < aabbMax) && all(worldPos > aabbMin))
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}
}

U16 findClipmapOnPosition(Clipmap clipmaps[kIndirectDiffuseClipmapCount], Vec3 cameraPos, Vec3 lookDir, Vec3 worldPos, F32 randFactor)
{
	randFactor = pow2(randFactor);

	F32 fade = computeClipmapFade(clipmaps[0], cameraPos, lookDir, worldPos);
	if(fade > randFactor)
	{
		return 0;
	}

	fade = computeClipmapFade(clipmaps[1], cameraPos, lookDir, worldPos);
	if(fade > randFactor)
	{
		return 1;
	}

	fade = computeClipmapFade(clipmaps[2], cameraPos, lookDir, worldPos);
	if(fade > randFactor)
	{
		return 2;
	}

	return 3;
}

Vec2 generateRandomUv(U32 sampleIdx, U32 sampleCount, U32 frame)
{
	const UVec3 r = rand3DPCG16(UVec3(frame % 16u, frame % 4u, frame % 32u));
	return hammersleyRandom16(sampleIdx, sampleCount, r);
}

HVec3 generateRandomPointInSphere(U32 sampleIdx, U32 sampleCount, U32 frame)
{
	return octahedronDecode(generateRandomUv(sampleIdx, sampleCount, frame));
}

// ===========================================================================
// RayGen                                                                    =
// ===========================================================================
#if ANKI_RAY_GEN_SHADER

struct Consts
{
	U32 m_clipmapIdx;
	U32 m_raysPerProbeCount;
	F32 m_padding1;
	F32 m_padding2;
};
ANKI_FAST_CONSTANTS(Consts, g_consts)

[Shader("raygeneration")] void main()
{
	const Clipmap clipmap = g_globalRendererConstants.m_indirectDiffuseClipmaps[g_consts.m_clipmapIdx];

	// Compute clipmap bounds
	const Mat3x4 cameraTrf = g_globalRendererConstants.m_matrices.m_cameraTransform;
	const Vec3 lookDir = -Vec3(cameraTrf.m_row0[2], cameraTrf.m_row1[2], cameraTrf.m_row2[2]);
	Vec3 clipmapAabbMin, clipmapAabbMax;
	computeClipmapBounds(clipmap, g_globalRendererConstants.m_cameraPosition, lookDir, clipmapAabbMin, clipmapAabbMax);

	// Compute probe info. Make sure you shoot coherent rays as much as possible by using the same direction on a specific wave
	const U32 sampleIdx = DispatchRaysIndex().x / clipmap.m_probeCountsTotal;
	const U32 probeIdx = DispatchRaysIndex().x % clipmap.m_probeCountsTotal;

	UVec3 probe3dIdx;
	unflatten3dArrayIndex(clipmap.m_probeCounts.z, clipmap.m_probeCounts.y, clipmap.m_probeCounts.x, probeIdx, probe3dIdx.z, probe3dIdx.y,
						  probe3dIdx.x);

	const Vec3 probeSize = clipmap.m_size / clipmap.m_probeCounts;
	const Vec3 cellWorldPos = probe3dIdx * probeSize + probeSize * 0.5 + clipmapAabbMin;

	// Trace
	const HVec3 dir = generateRandomPointInSphere(sampleIdx, g_consts.m_raysPerProbeCount, g_globalRendererConstants.m_frame);
	const F32 tMax = 1000.0; // TODO
	constexpr U32 traceFlags = RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES;
	GBufferLight<F16> gbuffer = (GBufferLight<F16>)0;
	F32 rayT = 0.0;
	Bool backfacing = false;
	const Bool hit = materialRayTrace<F16>(cellWorldPos, dir, 0.0, tMax, 1000.0, gbuffer, rayT, backfacing, traceFlags);

	HVec3 radiance;
	if(backfacing)
	{
		radiance = HVec3(1.0, 0.0, 1.0);
	}
	else
	{
		const Vec3 hitPos = cellWorldPos + dir * (rayT - 0.01);
		radiance = directLighting<F16>(gbuffer, hitPos, !hit, false, tMax, traceFlags | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH);
	}

	// Store result
	g_lightResultTex[UVec2(probeIdx, sampleIdx)] = HVec4(radiance, 0.0);
}
#endif // ANKI_RAY_GEN_SHADER

// ===========================================================================
// PopulateCaches                                                            =
// ===========================================================================
#if NOT_ZERO(ANKI_TECHNIQUE_PopulateCaches)
Texture2D<Vec4> g_lightResultTex : register(t0);

RWTexture3D<Vec4> g_radianceVolume : register(u0);

ConstantBuffer<GlobalRendererConstants> g_globalRendererConstants : register(b0);

struct Consts
{
	U32 m_clipmapIdx;
	U32 m_radianceProbeSize; // Size without border
	F32 m_padding1;
	F32 m_padding2;
};
ANKI_FAST_CONSTANTS(Consts, g_consts)

groupshared U32 g_octCoordValueSet[128]; // TODO

[NumThreads(RAYS_PER_PROBE_PER_FRAME, 1, 1)] void main(U32 svGroupIndex : SV_GroupIndex, UVec3 svGroupId : SV_GroupID)
{
	const Clipmap clipmap = g_globalRendererConstants.m_indirectDiffuseClipmaps[g_consts.m_clipmapIdx];

	const U32 octPixelCount = g_consts.m_radianceProbeSize * g_consts.m_radianceProbeSize;
	ANKI_ASSERT(octPixelCount <= 128);

	// Zero groupshared
	const U32 octPixelsPerThread = (octPixelCount + RAYS_PER_PROBE_PER_FRAME - 1) / RAYS_PER_PROBE_PER_FRAME;
	for(U32 i = 0; i < octPixelsPerThread; ++i)
	{
		const U32 octCoordIdx = svGroupIndex * octPixelsPerThread + i;
		if(octCoordIdx < octPixelCount)
		{
			g_octCoordValueSet[octCoordIdx] = 0;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	const U32 sampleIdx = svGroupIndex;
	const U32 probeIdx = svGroupId.z * clipmap.m_probeCounts.x * clipmap.m_probeCounts.y + svGroupId.y * clipmap.m_probeCounts.x + svGroupId.x;

	// Compute clipmap bounds
	Mat3x4 cameraTrf = g_globalRendererConstants.m_matrices.m_cameraTransform;
	Vec3 lookDir = -Vec3(cameraTrf.m_row0[2], cameraTrf.m_row1[2], cameraTrf.m_row2[2]);
	Vec3 clipmapAabbMin, clipmapAabbMax;
	computeClipmapBounds(clipmap, g_globalRendererConstants.m_cameraPosition, lookDir, clipmapAabbMin, clipmapAabbMax);

	// Compute previous frame clipmap bounds
	cameraTrf = g_globalRendererConstants.m_previousMatrices.m_cameraTransform;
	lookDir = -Vec3(cameraTrf.m_row0[2], cameraTrf.m_row1[2], cameraTrf.m_row2[2]);
	Vec3 prevClipmapAabbMin, prevClipmapAabbMax;
	computeClipmapBounds(clipmap, g_globalRendererConstants.m_previousMatrices.m_cameraTransform.getTranslationPart().xyz, lookDir,
						 prevClipmapAabbMin, prevClipmapAabbMax);

	const Vec3 probeSize = clipmap.m_size / clipmap.m_probeCounts;
	const Vec3 probeWorldPos = svGroupId * probeSize + probeSize * 0.5 + clipmapAabbMin;

	UVec3 volumeTexCoord = frac(probeWorldPos.xzy / clipmap.m_size.xzy) * clipmap.m_probeCounts.xzy;
	volumeTexCoord = min(volumeTexCoord, clipmap.m_probeCounts.xzy - 1u);

	const HVec3 radiance = SRV_TEXTURE(g_lightResultTex, UVec2(probeIdx, sampleIdx));

	const Vec2 octUv = generateRandomUv(sampleIdx, U32(RAYS_PER_PROBE_PER_FRAME), g_globalRendererConstants.m_frame);
	const UVec2 octCoord = min(octUv * g_consts.m_radianceProbeSize, g_consts.m_radianceProbeSize - 1);
	const U32 octCoordIdx = octCoord.y * g_consts.m_radianceProbeSize + octCoord.x;
	ANKI_ASSERT(octCoordIdx < octPixelCount);

	const Bool blendWithHistory = all(probeWorldPos > prevClipmapAabbMin) && all(probeWorldPos < prevClipmapAabbMax);
	HVec3 avgRadiance = 0.0;
	U32 iterationCount = 0;
	do
	{
		U32 origValue;
		InterlockedCompareExchange(g_octCoordValueSet[octCoordIdx], iterationCount, iterationCount + 1u, origValue);

		if(origValue == iterationCount)
		{
			UVec3 actualVolumeTexCoord;
			actualVolumeTexCoord.xy = octCoord + volumeTexCoord * (g_consts.m_radianceProbeSize + 2) + 1;
			actualVolumeTexCoord.z = volumeTexCoord.z;

			if(blendWithHistory)
			{
				const HVec3 prevValue = UAV_TEXTURE(g_radianceVolume, actualVolumeTexCoord).xyz;
				avgRadiance = lerp(prevValue, radiance, 0.1);
			}
			else
			{
				avgRadiance = radiance;
			}

			UAV_TEXTURE(g_radianceVolume, actualVolumeTexCoord).xyz = avgRadiance;

			iterationCount = kMaxU32;
		}
		else
		{
			++iterationCount;
		}

		AllMemoryBarrierWithGroupSync();
	} while(iterationCount < kMaxU32);

	// Set oct borders
	IVec2 borders[3];
	const U32 borderCount = octahedronBorder(g_consts.m_radianceProbeSize, octCoord, borders);
	for(U32 i = 0; i < borderCount; ++i)
	{
		IVec3 actualVolumeTexCoord;
		actualVolumeTexCoord.xy = octCoord + volumeTexCoord * (g_consts.m_radianceProbeSize + 2) + 1;
		actualVolumeTexCoord.xy += borders[i];
		actualVolumeTexCoord.z = volumeTexCoord.z;

		UAV_TEXTURE(g_radianceVolume, actualVolumeTexCoord).xyz = avgRadiance;
	}
}
#endif

// ===========================================================================
// Test                                                                      =
// ===========================================================================
#if NOT_ZERO(ANKI_TECHNIQUE_Test)
Texture2D<Vec4> g_depthTex : register(t0);
Texture2D<Vec4> g_gbufferRt2 : register(t1);

Texture2D<Vec4> g_blueNoiseTex : register(t2);

RWTexture2D<Vec4> g_outTex : register(u0);

ConstantBuffer<GlobalRendererConstants> g_globalRendererConstants : register(b0);

SamplerState g_linearAnyRepeatSampler : register(s0);

[NumThreads(8, 8, 1)] void main(UVec2 svDispatchThreadId : SV_DispatchThreadID)
{
	UVec2 viewportSize;
	g_outTex.GetDimensions(viewportSize.x, viewportSize.y);

	if(any(svDispatchThreadId >= viewportSize))
	{
		return;
	}

	const Vec3 normal = unpackNormalFromGBuffer(g_gbufferRt2[svDispatchThreadId]);

	const F32 depth = g_depthTex[svDispatchThreadId].r;
	const Vec2 uv = Vec2(svDispatchThreadId) / Vec2(viewportSize);
	const Vec2 ndc = uvToNdc(uv);
	const Vec4 worldPos4 = mul(g_globalRendererConstants.m_matrices.m_invertedViewProjectionJitter, Vec4(ndc, depth, 1.0));
	Vec3 worldPos = worldPos4.xyz / worldPos4.w;

	// Rand
	UVec2 noiseTexSize;
	g_blueNoiseTex.GetDimensions(noiseTexSize.x, noiseTexSize.y);
	Vec3 noise3 = g_blueNoiseTex[svDispatchThreadId % noiseTexSize];
	noise3 = animateBlueNoise(noise3, g_globalRendererConstants.m_frame);

	F32 noise = noise3.x;

	const Mat3x4 cameraTrf = g_globalRendererConstants.m_matrices.m_cameraTransform;
	const Vec3 lookDir = -Vec3(cameraTrf.m_row0[2], cameraTrf.m_row1[2], cameraTrf.m_row2[2]);

	const U16 clipmapIdx = findClipmapOnPosition(g_globalRendererConstants.m_indirectDiffuseClipmaps, g_globalRendererConstants.m_cameraPosition,
												 lookDir, worldPos, noise);
	if(clipmapIdx == 0)
	{
		g_outTex[svDispatchThreadId] = Vec4(1, 0, 0, 0);
	}
	else if(clipmapIdx == 1)
	{
		g_outTex[svDispatchThreadId] = Vec4(0, 1, 0, 0);
	}
	else if(clipmapIdx == 2)
	{
		g_outTex[svDispatchThreadId] = Vec4(0, 0, 1, 0);
	}
	else
	{
		g_outTex[svDispatchThreadId] = Vec4(1, 0, 1, 0);
	}

	return;

#	if 0
	if(clipmapIdx >= kIndirectDiffuseClipmapCount)
	{
		g_outTex[svDispatchThreadId] = 0.0;
		return;
	}

	const Vec3 uvw = worldPosToVolumeUvw(g_globalRendererConstants.m_indirectDiffuseClipmaps[clipmapIdx], worldPos);

	const IrradianceDice<F16> dice = loadIrradianceDice<F16>(g_clipmapVolumes, g_linearAnyRepeatSampler, uvw, clipmapIdx * 6);
	const HVec3 irradiance = evaluateIrradianceDice<F16>(dice, normal);

	g_outTex[svDispatchThreadId] = Vec4(irradiance, 0.0);
#	endif
}
#endif

// ===========================================================================
// VisualizeProbes                                                           =
// ===========================================================================
#if NOT_ZERO(ANKI_TECHNIQUE_VisualizeProbes)

struct VertIn
{
	U32 m_svVertexId : SV_VertexID;
	U32 m_svInstanceId : SV_InstanceID;
};

struct VertOut
{
	Vec4 m_svPosition : SV_Position;

	Vec3 m_probeCenter : PROBE_CENTER;
};

struct FragOut
{
	Vec4 m_color : SV_Target0;
	F32 m_svDepth : SV_Depth;
};

struct Consts
{
	U32 m_clipmapIdx;
	U32 m_radianceProbeSize; // Size without border
	U32 m_padding2;
	U32 m_padding3;
};
ANKI_FAST_CONSTANTS(Consts, g_consts)

ConstantBuffer<GlobalRendererConstants> g_globalRendererConstants : register(b0);

Texture3D<Vec4> g_radianceVolume : register(t0);

SamplerState g_linearAnyRepeatSampler : register(s0);

constexpr F32 kSphereRadius = 0.05;

#	if ANKI_VERTEX_SHADER
// Cube vertex positions indexed via SV_VertexID
constexpr Vec3 cubeVertices[8] = {Vec3(-1, -1, -1), Vec3(1, -1, -1), Vec3(1, 1, -1), Vec3(-1, 1, -1),
								  Vec3(-1, -1, 1),  Vec3(1, -1, 1),  Vec3(1, 1, 1),  Vec3(-1, 1, 1)};

// Index order for drawing the cube as a triangle list (36 indices, 12 triangles)
constexpr U32 cubeIndices[36] = {0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 5, 4, 7, 7, 6, 5, 4, 0, 3, 3, 7, 4, 3, 2, 6, 6, 7, 3, 4, 5, 1, 1, 0, 4};

VertOut main(VertIn input)
{
	const Clipmap clipmap = g_globalRendererConstants.m_indirectDiffuseClipmaps[g_consts.m_clipmapIdx];
	const Vec3 camPos = g_globalRendererConstants.m_cameraPosition;

	UVec3 cellCoord;
	unflatten3dArrayIndex(clipmap.m_probeCounts.z, clipmap.m_probeCounts.y, clipmap.m_probeCounts.x, input.m_svInstanceId, cellCoord.z, cellCoord.y,
						  cellCoord.x);

	const Mat3x4 cameraTrf = g_globalRendererConstants.m_matrices.m_cameraTransform;
	const Vec3 lookDir = -Vec3(cameraTrf.m_row0[2], cameraTrf.m_row1[2], cameraTrf.m_row2[2]);

	Vec3 clipmapAabbMin, clipmapAabbMax;
	computeClipmapBounds(clipmap, camPos, lookDir, clipmapAabbMin, clipmapAabbMax);
	const Vec3 probeSize = clipmap.m_size / clipmap.m_probeCounts;
	const Vec3 cellWorldPos = cellCoord * probeSize + probeSize * 0.5 + clipmapAabbMin;

	// Vert pos
	const U32 index = cubeIndices[input.m_svVertexId];
	Vec3 vertPos = cubeVertices[index];
	vertPos *= kSphereRadius;
	vertPos += cellWorldPos;

	VertOut output;
	output.m_svPosition = mul(g_globalRendererConstants.m_matrices.m_viewProjectionJitter, Vec4(vertPos, 1.0));
	output.m_probeCenter = cellWorldPos;

	return output;
}
#	endif // ANKI_VERTEX_SHADER

#	if ANKI_PIXEL_SHADER
FragOut main(VertOut input)
{
	const Clipmap clipmap = g_globalRendererConstants.m_indirectDiffuseClipmaps[g_consts.m_clipmapIdx];

	FragOut output;

	// Compute the far point
	const Vec2 ndc = uvToNdc(input.m_svPosition.xy / g_globalRendererConstants.m_renderingSize);
	const Vec4 v4 = mul(g_globalRendererConstants.m_matrices.m_invertedViewProjectionJitter, Vec4(ndc, 1.0, 1.0));
	const Vec3 farPoint = v4.xyz / v4.w;

	// Do sphere to view vec collision
	const Vec3 rayDir = normalize(farPoint - g_globalRendererConstants.m_cameraPosition);
	F32 t0, t1;
	const Bool collides = testRaySphere(g_globalRendererConstants.m_cameraPosition, rayDir, input.m_probeCenter, kSphereRadius, t0, t1);

	if(!collides)
	{
		discard;
	}

	const F32 t = min(t0, t1);
	const Vec3 collisionPoint = g_globalRendererConstants.m_cameraPosition + rayDir * t;

	const Vec4 p = mul(g_globalRendererConstants.m_matrices.m_viewProjectionJitter, Vec4(collisionPoint, 1.0));
	output.m_svDepth = p.z / p.w;

	const Vec3 normal = normalize(collisionPoint - input.m_probeCenter);

	Vec3 uvw = frac(input.m_probeCenter.xzy / clipmap.m_size.xzy);
	const UVec3 texelCoord = uvw * clipmap.m_probeCounts.xzy;

	uvw.xy = texelCoord.xy * (g_consts.m_radianceProbeSize + 2);
	uvw.xy += octahedronEncode(normal) * g_consts.m_radianceProbeSize + 1.0;
	uvw.xy /= clipmap.m_probeCounts.xz * (g_consts.m_radianceProbeSize + 2);

	uvw.z = (texelCoord.z + 0.5) / clipmap.m_probeCounts.y;

	Vec3 radiance = g_radianceVolume.SampleLevel(g_linearAnyRepeatSampler, uvw, 0.0).xyz;

	output.m_color = Vec4(radiance, 0.0);
	return output;
}
#	endif // ANKI_PIXEL_SHADER

#endif
